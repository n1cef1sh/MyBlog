---
layout: post
title: "点奈特学习记录"
categories: [.net, C#]

---

# 前记
作为平时的学习记录,内容大多来自[微软官方文档](https://docs.microsoft.com/zh-cn/)以及《C#图解教程》（第五版）。

# 2020.8.28
####  C#字符串
1.字符串内插  
在字符串左引号前添加$，可以在大括号 之间的字符串内包括变量。例如
```
Console.WriteLine($"Hello {aFriend}");
```
2.几个方法  
TrimStart、TrimEnd删除空格  
Replace替换  
Contains搜索包含
StartWith、EndWith搜索开头结尾
  
### VisualStudio基础使用
- 创建.NETCore控制台应用程序，添加断点、条件断点调试，F11单步调试程序。 
- 使用“即时窗口”，以交互方式更改变量值。
- 发布应用创建的文件  
x.deps.json 运行时依赖项文件
 x.runtimeconfig.json 运行时配置文件  
x.dll 依赖于框架的部署版本，执行此动态链接库可用
```
dotnet x.dll
```
- 创建.NETStandard库  
编写类库项目，生成解决方案验证正确与否。添加控制台应用，将类库项目添加到应用依赖项引用。
- 对库进行单元测试  
新建MStest测试项目，添加被测项目的引用。写完保存时选择“保存时使用编码”，选择“Unicode (UTF-8 带签名) - 代码页 65001”，即可测试。
- Assert断言常用方法  

![QQ截图20200829211204.png](https://i.loli.net/2020/08/29/5dH2eLVqAjyQPOC.png)

- 安装和使用NuGet包  
安装略，选择“工具”——“NuGet包管理器”——“包管理器控制台”，在DefaultProject选择项目，输入命令
```
Install-Package Newtonsoft.Json
```

![QQ截图20200828160448.png](https://i.loli.net/2020/08/29/pf5hGXkKxeW3qOd.png)
项目中使用using引进包，JsonConvert.SerializeObject方法将对象转换为可人工读取的字符串。

### 控制台应用Calculator
- 修复被零除的错误
- NaN(Not a Number)，用于处理计算出现的错误情况，例如0.0/0.0或者求负数的平方根。
- 分为两个类 Calculator负责计算，Program类处理用户界面和错误捕获
- 新建项目“类库”，并在原项目中添加对其引用，将之前Calculator类及其代码剪切到类库CalculatorLibrary的命名空间里。**注意**，需要使Calculator类public从而在库外部公开它才可使用。
- 写入日志：使用Trace类，引入System.Diagnostics包。添加构造函数
```
public Calculator()
     {
         StreamWriter logFile = File.CreateText("calculator.log");
         Trace.Listeners.Add(new TextWriterTraceListener(logFile));
         Trace.AutoFlush = true;
         Trace.WriteLine("Starting Calculator Log");
         Trace.WriteLine(String.Format("Started {0}", System.DateTime.Now.ToString()));
     }
```
把之前用来计算的静态方法改为成员方法，在每个计算后添加写入日志的代码。运行程序后，在文件目录下找到calculator.log。
- 写入JSON文件  
添加NuGet包Newtonsoft.json，创建JsonWriter成员对象，改写构造函数，最后添加一种方法从而完成JSON语法
```
public void Finish()
 {
     writer.WriteEndArray();
     writer.WriteEndObject();
     writer.Close();
 }
```

### 简单的创建WPF应用程序

### 简单的创建Windows窗体应用程序
与之前的简单安卓app类似。

# 2020.9.2
## 简单的窗体应用
计时数学测验没啥好说的。        
匹配游戏MatchingGames
- 添加了游戏计时器，System.Windows.Forms命名空间下的Timer控件，和所在的Form属于同一个进程。Timer控件只有绑定了Tick事件和设置Enabled属性为True周才会自动计时。      
- 添加了音效，使用System.Media命名空间。

## 字符串内插的高级方案
- 在内插字符串中使用转义序列        
若要逐字解释转义序列，可使用逐字字符串文本。 内插逐字字符串以 $ 字符开头，后跟 @ 字符。 从 C# 8.0 开始，可以按任意顺序使用 $ 和 @ 标记：$@"..." 和 @$"..." 均为有效的内插逐字字符串。

```
var userName = "pyq";
var stringWithEscapes = $"C:\\Users\\{userName}\\Documents";
var verbatimInterpolated = $@"C:\Users\{userName}\Documents";
Console.WriteLine(stringWithEscapes);
Console.WriteLine(verbatimInterpolated);
// C:\Users\pyq\Documents
// C:\Users\pyq\Documents
```

- 使用字符串插值创建区域性特定的结果字符串      
默认情况下，内插字符串将 CultureInfo.CurrentCulture 属性定义的当前区域性用于所有格式设置操作。使用内插字符串到System.FormattableString 实例的隐式转换，并调用它的 ToString(IFormatProvider) 方法来创建区域性特定的结果字符串。
  
```
var cultures = new System.Globalization.CultureInfo[]
{
    System.Globalization.CultureInfo.GetCultureInfo("en-US"),
    System.Globalization.CultureInfo.GetCultureInfo("en-GB"),
    System.Globalization.CultureInfo.GetCultureInfo("nl-NL"),
    System.Globalization.CultureInfo.InvariantCulture
};

var date = DateTime.Now;
var number = 31_415_926.536;
FormattableString message = $"{date,20}{number,20:N3}";
foreach (var culture in cultures)
{
    var cultureSpecificMessage = message.ToString(culture);
    Console.WriteLine($"{culture.Name,-10}{cultureSpecificMessage}");
}

// Expected output is like:
// en-US       5/17/18 3:44:55 PM      31,415,926.536
// en-GB      17/05/2018 15:44:55      31,415,926.536
// nl-NL        17-05-18 15:44:55      31.415.926,536
//            05/17/2018 15:44:55      31,415,926.536
```



## 索引和范围
0 索引与 sequence[0] 相同。 ^0 索引与 sequence[sequence.Length] 相同。 表达式 sequence[^0] 不会引发异常，就像 sequence[sequence.Length] 一样。 对于任何数字 n，索引 ^n 与 sequence[sequence.Length - n] 相同。

```
string[] words = new string[]
{
                // index from start    index from end
    "The",      // 0                   ^9
    "quick",    // 1                   ^8
    "brown",    // 2                   ^7
    "fox",      // 3                   ^6
    "jumped",   // 4                   ^5
    "over",     // 5                   ^4
    "the",      // 6                   ^3
    "lazy",     // 7                   ^2
    "dog"       // 8                   ^1
};              // 9 (or words.Length) ^0
```
## 类型系统
CTS(通用类型系统)中值类型和引用类型
![QQ截图20200902170229.png](https://i.loli.net/2020/09/02/6eCZjb8TW75mAsU.png)

- 值类型：分为结构和枚举。变量直接包含其值，在声明变量的任何上下文中内联分配内存，没有单独的堆分配或垃圾回收开销。
- 引用类型：类、委托、数组或接口。     
声明变量时一直包含值null，直到new对象或分配其他对象。创建对象后，内存会在托管堆上进行分配，并且变量只保留对对象位置的引用。

- 装箱boxing&取消装箱unboxing  
装箱：值类型➡引用类型  
拆箱：引用类型➡值类型  

```
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```
![QQ截图20200902183902.png](https://i.loli.net/2020/09/02/qcF6Yi7z3mUl5QW.png)

装箱时生成的是全新的引用对象，会有时间损耗，造成效率降低。所以应尽量避免装箱。一般可通过**重载函**数和**泛型**避免。

## 委托（Delegate）
**建议不要直接在全局命名空间中声明委托类型（或其他类型）。**

委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。  
使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。  
声明和定义委托分为4个步骤：  

1.声明一个委托（函数指针）  
2.创建委托对象  
3.创造符合委托格式的函数。（指针指向的函数）  
4.将函数名称赋值给委托。  

更详细的
[解释和实例](https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98)

## 事件Event
事件是后期绑定机制，事件是对象用于（向系统中的所有相关组件）广播已发生事情的一种方式。 任何其他组件都可以订阅事件，并在事件引发时得到通知。  
定义事件

```
public event EventHandler<FileLisArgs> Progress;
```
引发事件时，使用委托调用语法调用事件
```
Process?.Invoke(this, new FileLisArgs(file));
//?. 运算符可确保在事件没有订阅服务器时不引发事件。
```
使用 += 运算符订阅事件, -=取消订阅。

# 9.3
### 变量
- c#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。

### 参数
#### 值参数

```
class Program
        {
            static void MyMethod(MyClass f1, int f2)
            {
                f1.Val = f1.Val + 5;
                f2 = f2 + 5;
                Console.WriteLine($"f1.Val:{f1.Val}, f2:{f2}");
            }

            static void Main()
            {
                MyClass a1 = new MyClass();
                int a2 = 10;
                MyMethod(a1, a2);
                Console.WriteLine($"a1.Val:{a1.Val},a2:{a2}");
            }
        }
//f1.Val:25, f2:15
//a1.Val:25, a2:10
```
- 方法开始前，用作实参的变量a2已经在栈里了
- 方法开始时，系统在栈里为形参分配空间，并从实参复制值。  
1、a1是引用类型，所以引用被复制，结果实参和形参引用堆中的同一个对象（也就是数据20）  
2、a2是值类型，所以值被复制，产生一个独立的数据项
- 方法结尾，f2和对象f1的字段都被加上了5  
1、执行结束后，形参从栈中弹出  
2、a2值类型，其值不受方法行为的影响
3、a1引用类型，其值被方法行为影响

#### 引用参数
- 使用时，必须在声明和调用时都使用ref修饰符
- 实参必须是变量，在用作实参前必须被赋值。若是引用类型变量，可赋值为引用或null。
- 不会在栈上为形参分配内存
- 形参的参数名将作为实参变量的别名，指向相同的内存位置  
将上例f1 f2修改为引用参数后，输出为

```
//f1.Val:25, f2:15
//a1.Val:25, a2:15
```
- 方法调用前，将要被用作实参的变量a1和a2已经在栈里了
- 在方法的开始，形参名被设置为实参的别名，a1和f1引用相同的内存位置，a2和f2亦然。
- 在方法结束位置，f1的对象的字段和f2都被加上了5
- 方法执行后，形参名称失效，但是值类型a2的值和引用类型a1所指向的对象的值都被方法内的行为改变了

#### 引用类型作为值参数和引用参数
- 作为值类型传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参的关联，并且方法结束后，新对象也不复存在。

```
class MyClass
        {
            public int Val = 20;
        }

        class Program
        {
            static void RefAsParameter(MyClass f1)
            {
                f1.Val = 50;
                Console.WriteLine($"After member assignment: {f1.Val}");
                f1 = new MyClass();
                Console.WriteLine($"After new object creation: {f1.Val}");
            }

            static void Main()
            {
                MyClass a1 = new MyClass();
                Console.WriteLine($"Before Method call: {a1.Val}");
                RefAsParameter(a1);
                Console.WriteLine($"After method call: {a1.Val}");
            }
        }
//Before Method call: 20
//After member assignment: 50
//After new object creation: 20
//After method call: 50
```

- 作为引用参数：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参引用的值。  
在上例代码基础上，添加ref关键字，输出为

```
Before Method call: 20
After member assignment: 50
After new object creation: 20
After method call: 20
```

#### 输出参数
和引用参数不同的地方  
- 在方法内部，给输出参数赋值之后才能读取它。也就是在方法调用前没有必要给实参赋值。
- 在方法内部，在方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。
- 从C#7.0开始，可以在调用方法时在参数列表中添加一个变量类型，以其作为变量声明  

```
//原来的写法
 static void Main()
            {
                MyClass a1 = new MyClass();
                int a2;
                MyMethod(out a1, out a2);
            }
//新的写法
static void Main()
            {
                MyMethod(out MyClass a1, out int a2);
            }
```

#### 参数数组
- 一个参数列表只能有一个参数数组
- 若有，必须是列表中的最后一个
- 所表示的所有参数必须是同一类型
- params修饰符：在声明时需要，调用时不允许有。
- 数组在堆中被创建时，实参的值被复制到数组中。
- 如果数组参数时值类型，则值被复制，实参在方法内部不受影响；如果数组参数是引用类型，则引用被赋值，实参引用的对象在方法内部会受影响。





