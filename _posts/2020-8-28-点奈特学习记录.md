---
layout: post
title: "点奈特学习记录"
categories: [.net, C#]

---

# 前记
作为平时的学习记录,内容大多来自[微软官方文档](https://docs.microsoft.com/zh-cn/)以及《C#图解教程》（第五版）。

# 2020.8.28
####  C#字符串
1.字符串内插  
在字符串左引号前添加$，可以在大括号 之间的字符串内包括变量。例如
```
Console.WriteLine($"Hello {aFriend}");
```
2.几个方法  
TrimStart、TrimEnd删除空格  
Replace替换  
Contains搜索包含
StartWith、EndWith搜索开头结尾
  
### VisualStudio基础使用
- 创建.NETCore控制台应用程序，添加断点、条件断点调试，F11单步调试程序。 
- 使用“即时窗口”，以交互方式更改变量值。
- 发布应用创建的文件  
x.deps.json 运行时依赖项文件
 x.runtimeconfig.json 运行时配置文件  
x.dll 依赖于框架的部署版本，执行此动态链接库可用
```
dotnet x.dll
```
- 创建.NETStandard库  
编写类库项目，生成解决方案验证正确与否。添加控制台应用，将类库项目添加到应用依赖项引用。
- 对库进行单元测试  
新建MStest测试项目，添加被测项目的引用。写完保存时选择“保存时使用编码”，选择“Unicode (UTF-8 带签名) - 代码页 65001”，即可测试。
- Assert断言常用方法  

![QQ截图20200829211204.png](https://i.loli.net/2020/08/29/5dH2eLVqAjyQPOC.png)

- 安装和使用NuGet包  
安装略，选择“工具”——“NuGet包管理器”——“包管理器控制台”，在DefaultProject选择项目，输入命令
```
Install-Package Newtonsoft.Json
```

![QQ截图20200828160448.png](https://i.loli.net/2020/08/29/pf5hGXkKxeW3qOd.png)
项目中使用using引进包，JsonConvert.SerializeObject方法将对象转换为可人工读取的字符串。

### 控制台应用Calculator
- 修复被零除的错误
- NaN(Not a Number)，用于处理计算出现的错误情况，例如0.0/0.0或者求负数的平方根。
- 分为两个类 Calculator负责计算，Program类处理用户界面和错误捕获
- 新建项目“类库”，并在原项目中添加对其引用，将之前Calculator类及其代码剪切到类库CalculatorLibrary的命名空间里。**注意**，需要使Calculator类public从而在库外部公开它才可使用。
- 写入日志：使用Trace类，引入System.Diagnostics包。添加构造函数
```
public Calculator()
     {
         StreamWriter logFile = File.CreateText("calculator.log");
         Trace.Listeners.Add(new TextWriterTraceListener(logFile));
         Trace.AutoFlush = true;
         Trace.WriteLine("Starting Calculator Log");
         Trace.WriteLine(String.Format("Started {0}", System.DateTime.Now.ToString()));
     }
```
把之前用来计算的静态方法改为成员方法，在每个计算后添加写入日志的代码。运行程序后，在文件目录下找到calculator.log。
- 写入JSON文件  
添加NuGet包Newtonsoft.json，创建JsonWriter成员对象，改写构造函数，最后添加一种方法从而完成JSON语法
```
public void Finish()
 {
     writer.WriteEndArray();
     writer.WriteEndObject();
     writer.Close();
 }
```

### 简单的创建WPF应用程序

### 简单的创建Windows窗体应用程序
与之前的简单安卓app类似。

# 2020.9.2
## 简单的窗体应用
计时数学测验没啥好说的。        
匹配游戏MatchingGames
- 添加了游戏计时器，System.Windows.Forms命名空间下的Timer控件，和所在的Form属于同一个进程。Timer控件只有绑定了Tick事件和设置Enabled属性为True周才会自动计时。      
- 添加了音效，使用System.Media命名空间。

## 字符串内插的高级方案
- 在内插字符串中使用转义序列        
若要逐字解释转义序列，可使用逐字字符串文本。 内插逐字字符串以 $ 字符开头，后跟 @ 字符。 从 C# 8.0 开始，可以按任意顺序使用 $ 和 @ 标记：$@"..." 和 @$"..." 均为有效的内插逐字字符串。

```
var userName = "pyq";
var stringWithEscapes = $"C:\\Users\\{userName}\\Documents";
var verbatimInterpolated = $@"C:\Users\{userName}\Documents";
Console.WriteLine(stringWithEscapes);
Console.WriteLine(verbatimInterpolated);
// C:\Users\pyq\Documents
// C:\Users\pyq\Documents
```

- 使用字符串插值创建区域性特定的结果字符串      
默认情况下，内插字符串将 CultureInfo.CurrentCulture 属性定义的当前区域性用于所有格式设置操作。使用内插字符串到System.FormattableString 实例的隐式转换，并调用它的 ToString(IFormatProvider) 方法来创建区域性特定的结果字符串。
  
```
var cultures = new System.Globalization.CultureInfo[]
{
    System.Globalization.CultureInfo.GetCultureInfo("en-US"),
    System.Globalization.CultureInfo.GetCultureInfo("en-GB"),
    System.Globalization.CultureInfo.GetCultureInfo("nl-NL"),
    System.Globalization.CultureInfo.InvariantCulture
};

var date = DateTime.Now;
var number = 31_415_926.536;
FormattableString message = $"{date,20}{number,20:N3}";
foreach (var culture in cultures)
{
    var cultureSpecificMessage = message.ToString(culture);
    Console.WriteLine($"{culture.Name,-10}{cultureSpecificMessage}");
}

// Expected output is like:
// en-US       5/17/18 3:44:55 PM      31,415,926.536
// en-GB      17/05/2018 15:44:55      31,415,926.536
// nl-NL        17-05-18 15:44:55      31.415.926,536
//            05/17/2018 15:44:55      31,415,926.536
```



## 索引和范围
0 索引与 sequence[0] 相同。 ^0 索引与 sequence[sequence.Length] 相同。 表达式 sequence[^0] 不会引发异常，就像 sequence[sequence.Length] 一样。 对于任何数字 n，索引 ^n 与 sequence[sequence.Length - n] 相同。

```
string[] words = new string[]
{
                // index from start    index from end
    "The",      // 0                   ^9
    "quick",    // 1                   ^8
    "brown",    // 2                   ^7
    "fox",      // 3                   ^6
    "jumped",   // 4                   ^5
    "over",     // 5                   ^4
    "the",      // 6                   ^3
    "lazy",     // 7                   ^2
    "dog"       // 8                   ^1
};              // 9 (or words.Length) ^0
```
## 类型系统
CTS(通用类型系统)中值类型和引用类型
![QQ截图20200902170229.png](https://i.loli.net/2020/09/02/6eCZjb8TW75mAsU.png)

- 值类型：分为结构和枚举。变量直接包含其值，在声明变量的任何上下文中内联分配内存，没有单独的堆分配或垃圾回收开销。
- 引用类型：类、委托、数组或接口。     
声明变量时一直包含值null，直到new对象或分配其他对象。创建对象后，内存会在托管堆上进行分配，并且变量只保留对对象位置的引用。

- 装箱boxing&取消装箱unboxing  
装箱：值类型➡引用类型  
拆箱：引用类型➡值类型  

```
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```
![QQ截图20200902183902.png](https://i.loli.net/2020/09/02/qcF6Yi7z3mUl5QW.png)

装箱时生成的是全新的引用对象，会有时间损耗，造成效率降低。所以应尽量避免装箱。一般可通过**重载函**数和**泛型**避免。

## 委托（Delegate）
**建议不要直接在全局命名空间中声明委托类型（或其他类型）。**

委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。  
使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。  
声明和定义委托分为4个步骤：  

1.声明一个委托（函数指针）  
2.创建委托对象  
3.创造符合委托格式的函数。（指针指向的函数）  
4.将函数名称赋值给委托。  

更详细的
[解释和实例](https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98)

## 事件Event
事件是后期绑定机制，事件是对象用于（向系统中的所有相关组件）广播已发生事情的一种方式。 任何其他组件都可以订阅事件，并在事件引发时得到通知。  
定义事件

```
public event EventHandler<FileLisArgs> Progress;
```
引发事件时，使用委托调用语法调用事件
```
Process?.Invoke(this, new FileLisArgs(file));
//?. 运算符可确保在事件没有订阅服务器时不引发事件。
```
使用 += 运算符订阅事件, -=取消订阅。

# 9.3
### 变量
- c#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。

### 参数
#### 值参数

```
class Program
        {
            static void MyMethod(MyClass f1, int f2)
            {
                f1.Val = f1.Val + 5;
                f2 = f2 + 5;
                Console.WriteLine($"f1.Val:{f1.Val}, f2:{f2}");
            }

            static void Main()
            {
                MyClass a1 = new MyClass();
                int a2 = 10;
                MyMethod(a1, a2);
                Console.WriteLine($"a1.Val:{a1.Val},a2:{a2}");
            }
        }
//f1.Val:25, f2:15
//a1.Val:25, a2:10
```
- 方法开始前，用作实参的变量a2已经在栈里了
- 方法开始时，系统在栈里为形参分配空间，并从实参复制值。  
1、a1是引用类型，所以引用被复制，结果实参和形参引用堆中的同一个对象（也就是数据20）  
2、a2是值类型，所以值被复制，产生一个独立的数据项
- 方法结尾，f2和对象f1的字段都被加上了5  
1、执行结束后，形参从栈中弹出  
2、a2值类型，其值不受方法行为的影响
3、a1引用类型，其值被方法行为影响

#### 引用参数
- 使用时，必须在声明和调用时都使用ref修饰符
- 实参必须是变量，在用作实参前必须被赋值。若是引用类型变量，可赋值为引用或null。
- 不会在栈上为形参分配内存
- 形参的参数名将作为实参变量的别名，指向相同的内存位置  
将上例f1 f2修改为引用参数后，输出为

```
//f1.Val:25, f2:15
//a1.Val:25, a2:15
```
- 方法调用前，将要被用作实参的变量a1和a2已经在栈里了
- 在方法的开始，形参名被设置为实参的别名，a1和f1引用相同的内存位置，a2和f2亦然。
- 在方法结束位置，f1的对象的字段和f2都被加上了5
- 方法执行后，形参名称失效，但是值类型a2的值和引用类型a1所指向的对象的值都被方法内的行为改变了

#### 引用类型作为值参数和引用参数
- 作为值类型传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参的关联，并且方法结束后，新对象也不复存在。

```
class MyClass
        {
            public int Val = 20;
        }

        class Program
        {
            static void RefAsParameter(MyClass f1)
            {
                f1.Val = 50;
                Console.WriteLine($"After member assignment: {f1.Val}");
                f1 = new MyClass();
                Console.WriteLine($"After new object creation: {f1.Val}");
            }

            static void Main()
            {
                MyClass a1 = new MyClass();
                Console.WriteLine($"Before Method call: {a1.Val}");
                RefAsParameter(a1);
                Console.WriteLine($"After method call: {a1.Val}");
            }
        }
//Before Method call: 20
//After member assignment: 50
//After new object creation: 20
//After method call: 50
```

- 作为引用参数：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参引用的值。  
在上例代码基础上，添加ref关键字，输出为

```
Before Method call: 20
After member assignment: 50
After new object creation: 20
After method call: 20
```

#### 输出参数
和引用参数不同的地方  
- 在方法内部，给输出参数赋值之后才能读取它。也就是在方法调用前没有必要给实参赋值。
- 在方法内部，在方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。
- 从C#7.0开始，可以在调用方法时在参数列表中添加一个变量类型，以其作为变量声明  

```
//原来的写法
 static void Main()
            {
                MyClass a1 = new MyClass();
                int a2;
                MyMethod(out a1, out a2);
            }
//新的写法
static void Main()
            {
                MyMethod(out MyClass a1, out int a2);
            }
```

#### 参数数组
- 一个参数列表只能有一个参数数组
- 若有，必须是列表中的最后一个
- 所表示的所有参数必须是同一类型
- params修饰符：在声明时需要，调用时不允许有。
- 数组在堆中被创建时，实参的值被复制到数组中。
- 如果数组参数时值类型，则值被复制，实参在方法内部不受影响；如果数组参数是引用类型，则引用被赋值，实参引用的对象在方法内部会受影响。

# 9.5
#### 属性
- 属性和后备字段的命名约定。  

```
    private int firstField;
    //或写成_firstField
    public  int FirstField;
```
- get/set访问器至少有一个必须被定义，否则编写会出错。
- 属性比公有字段更好：  
1、是函数成员而非数据成员，允许处理输入和输出。      
2、可以只读或只写  
3、编译后的变量和编译后的属性语义不同

#### readonly修饰符
- const字段只能在声明语句中初始化，readonly除此之外还可以在类的任何构造函数设置。
- const字段的值必须可在编译时决定，readonly字段的值可以在运行时决定。这使得允许在不同环境或不同构造函数中设置不同的值。
- const行为总是静态的，而readonly字段：可以是实例字段也可以是静态字段；在内存中有存储位置。

####  索引器
- 可以认为索引器是为类的**多个数据成员**提供get和set访问的**属性**。
- 索引器没有名称，用this。

#### 分部方法
- 返回类型必须是void
- 签名不能包括访问修饰符，这使得分部方法是隐式私有的
- 参数列表不能包含out参数
- 在定义和声明中必须在void前添加partial


# 9.6

#### 类和继承
- 屏蔽基类的成员：在派生类中声明一个相同名称相同类型的成员。要让编译器知道是故意屏蔽的话，可使用new修饰符，否则会警告隐藏了继承的成员。
- 签名由名称和参数列表组成，不包括返回类型。

##### 覆写
- 覆写和被覆写必须有相同的可访问性；
- 方法、属性、索引器和事件都可以被声明为virtual和override；
- static和非虚方法不能覆写。
- 当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为override的方法的最高派生版本。

##### 析构函数执行
- 初始化实例成员→调用基类构造函数→执行实例构造函数的方法体
- 如果派生类使用一个指定的基类构造函数而不是无参数构造函数，必须在构造函数初始化语句中指定它  
1、使用base并指明使用哪一个基类构造函数  


```
    public MyDerivedClass(int x, string s):base(s,x){
        ……
    }
```
2、使用this并指明使用**当前**类的哪一个构造函数

```
    public MyClass(int x):this(x,"using default string"){
        ……
    }
```
这种语法的好处是，如果一个类有好几个构造函数，并且都需要在对象构造过程开始时执行一些公共的代码，就可以提取公共代码作为一个公共构造函数（设置为public），被其他所有的构造函数用作构造函数初始化语句。

##### 程序集间的继承
- 增加对其他程序集的引用是告诉编译器所需的类型在哪里定义。
- 增加using指令允许你引用其他的类而不必使用它们的完全限定名称。


##### 成员访问修饰符
五种访问级别如图所示
![蜂蜜浏览器_IMG_20200906_111340.jpg](https://i.loli.net/2020/09/06/RiI9TJro8eyMwsp.jpg)

![QQ截图20200906112308.png](https://i.loli.net/2020/09/06/hc8gZVRJ2r6tXQa.png)

#####  扩展方法
- 声明扩展方法的类必须声明为static
- 扩展方法本身必须声明为static
- 必须包含关键字this作为它的第一个参数类型


```
    static class ExtendMyData{
        public static double Average(this MyData md){
            ……
        }
    }
```

#### 表达式和运算符
##### 字面量
- 无后缀的实数字面量是double类型
- 字符字面量的不同格式

```
    char c1 = "d";//单个字符
    char c2 = "\n";//简单转义序列
    char c3 = "\x0061";//十六进制转义序列
    char c4 = "\u005a";//Unicode转义序列
    
```

# 9.7
#### 表达式和运算符
- 在C#中数字不具有布尔意义
##### 比较操作
- 对大多数引用类型来说，只比较他们的引用（浅比较）：如果指向内存中相同的对象则返回true，否则false。即使内存中两个**分离的对象**在所有其他地方都是**完全相等的**。
- string类型比较相等性时，会比较长度和内容，区分大小写，即深比较。

##### 条件逻辑运算符
使用“短路”模式操作，如果计算Expr1之后结果已经确定了，将会跳过Expr2的求值。因此不要在Expr2中放置带副作用的表达式（比如改变一个值），因为可能不会计算。

##### 移位运算符
- 当操作数时有符号整数时，如果最左边的位是1（标志一个负数），在左边移开的位置用1而不是0填充。
- 对于正数或无符号数，左边移开的位置用0填充。
- 把整数左移一位的结果与把它乘以2的结果相同，右移一位的结果和除以2相同。

##### 用户定义的类型转换
- 隐式转换：决定在特定上下文中使用特定类型时，如有需要，编译器会自动执行转换。转换运算符是implicit。

```
    public static implicit operator TargetType(SourceType Identifier){
        ……
        return ObjectOfTargetType;
    }
```
- 显式转换：编译器只在使用显式转换运算符时才执行转换。转换运算符explicit。
```
    public static explicit operator TargetType(SourceType Identifier){
        ……
        return ObjectOfTargetType;
    }
```
使用explicit运算符时，需要显式使用转换运算符，也就是把想要把表达式转换成的目标类型的名称组成，放在一对圆括号内部。

##### 运算符重载
- 一元运算符的重载方法带一个单独的class或struct类型的参数
- 二元运算符的重载方法带两个参数，其中至少有一个必须是class或struct类型。
- 重载的方法声明必须同时使用public和static
- 运算符必须是要操作的类或结构的成员

##### typeof运算符
- 返回作为其参数的任何类型的System.Type对象，可以了解类型的特征。对于任何已知类型，只有一个System.Type对象。


```
class SomeClass
    {
        public int Field1;
        public int Field2;

        public void Method1() { }
        public int Method2() { return 1; }
    }

    class Program
    {
        static void Main()
        {
            Type t = typeof(SomeClass);
            FieldInfo[] fi = t.GetFields();
            MethodInfo[] mi = t.GetMethods();

            foreach (FieldInfo f in fi)
                Console.WriteLine($"Field: {f.Name}");
            foreach (MethodInfo m in mi)
                Console.WriteLine($"Method: {m.Name}");
        }
    }
```
输出结果为

```
Field: Field1
Field: Field2
Method: Method1
Method: Method2
Method: GetType
Method: ToString
Method: Equals
Method: GetHashCode
```
GetType方法也会调用typeof运算符，该方法对每个类型的每个对象都有效。







