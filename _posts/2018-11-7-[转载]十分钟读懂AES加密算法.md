---
layout: post
title: "[转载]十分钟读懂AES加密算法"
date: 2018-11-7
excerpt: "转载一篇关于AES加密算法的文章作为学习"
tags: [Crpyto]
comments: true
---

# 前言
对AES加密算法认知过于浅显，看到一篇翻译过来的配有漫画的文章，粗读一遍感觉很不错，转载过来作为学习。

转载来源[Lee_rw的博客](https://blog.csdn.net/lrwwll/article/details/78069013)

英文原文[Moserware的《A Stick Figure Guide to the Advanced Encryption Standard(AES)》](http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html)

# 正文
很久很久以前
![](https://i.loli.net/2018/11/10/5be6b5fb2db59.png)

AES:我每天处理很多数据。我把很多很神奇的秘密数据加密成枯燥的数据包给你的WIFI路由器，这些都是我做的！

![](https://i.loli.net/2018/11/09/5be561f2c441e.png)

AES:但是还是没有人关心的我故事，呜呜呜。。。

![](https://i.loli.net/2018/11/09/5be56203b11be.png)

AES:我的故事可以比灰姑娘的故事更传奇呢，因为我现在可是分组密码世界的国王！ 

![](https://i.loli.net/2018/11/10/5be6b6e756aa6.png)

你还没走啊，想听我的故事？来咱们开始造作吧… 

![](https://i.loli.net/2018/11/10/5be6b70e76348.png)

曾经啊（1975以前），除了保密局没有办法去评判那种加密算法更好，有人说是EBG13 vf terng, 也有人说是Double ROT13，各执一词。

![](https://i.loli.net/2018/11/10/5be6b734d7f23.png)

终于有人站出来号召创建一个好的安全加密算法。 

![](https://i.loli.net/2018/11/10/5be6b749694bf.png)

这时一个强有力的竞争者占了出来，他的名字就是IBM！

![](https://i.loli.net/2018/11/10/5be6b75da294d.png)

在国家安全局的修改之后，他被钦定为数据加密标准，也就是DES。因为人家有更加短的密钥和更加强壮的S盒。

![](https://i.loli.net/2018/11/10/5be6b7b97084a.png)

DES已经统治了20多年了，学术界也开始研究他。这是第一次细致的研究。从此，现代密码学诞生。 

![](https://i.loli.net/2018/11/10/5be6b7b1bc0f4.png)

这些年间，前赴后继的攻击者挑战DES,而且DES被打败过几次。 

![](https://i.loli.net/2018/11/10/5be6b7bb76c87.png)

阻止攻击的唯一办法就是使用DES算法三次也就是’Triple-DES’，这个办法很可行，但是真的是很慢。

![](https://i.loli.net/2018/11/10/5be6b7af5c7b1.png)

有一个需求来了，他们需要像’Triple-DES’一样强壮但是更快更灵活的加密算法。(~1997) 

![](https://i.loli.net/2018/11/10/5be6b7b06dbba.png)

大家都跃跃欲试。 

![](https://i.loli.net/2018/11/10/5be6d47128c21.png)

我的创造者也就是AES的发明者，Vincent Rijmen和Joan Daemen也在他们之中，他们俩把他们的姓结合在一起给我作为乳名：Rijndael。 

![](https://i.loli.net/2018/11/10/5be6d4740bfc8.png)
![](https://i.loli.net/2018/11/10/5be6d47994aa4.png)

不出所料，AES赢了。 

![](https://i.loli.net/2018/11/10/5be6d47e0fa24.png)

而且，AES成了加密界的国王，他无处不在。Intel甚至在他们的芯片中为我量身定制了底层指令来让AES执行地更快！ 

![](https://i.loli.net/2018/11/10/5be6d48ab25b2.png)

但是加密算法是怎么工作的呢？我们来到下一部分

## 密码学基础

![](https://i.loli.net/2018/11/10/5be6d487374cb.png)

想明白加密算法是怎么工作的你需要知道3个idea来理解这些东西。

### 1. 混淆

![](https://i.loli.net/2018/11/10/5be6d4894cae0.png)

在明文和加密之后的秘文之间建立某种关系是很好的想法。一个混淆的例子是凯撒密码。密文的每个字母对应于明文字母的后面第三个字母。

### 2. 扩散

![](https://i.loli.net/2018/11/10/5be6d49f0eeef.png)

另一个很好的想法是扩散信息。一个例子是简单的列转置。

### 3. 保密密钥

![](https://i.loli.net/2018/11/10/5be6d4a9e85dc.png)

千百年来，我们发现假设没有人知道你的加密方法是一件愚蠢的事情，总会有人最终知道的。

![](https://i.loli.net/2018/11/10/5be6d4a583a89.png)

但是具体是怎么工作的呢？我们看下一部分

## 详细过程

![](https://i.loli.net/2018/11/10/5be6d4a66b0b3.png)


但是在我告诉你们之前，你们得先签署这份协议！ 

![](https://i.loli.net/2018/11/10/5be6d4b1edb58.png)

你需要先签这个玩意儿 

![](https://i.loli.net/2018/11/10/5be6d4add8a4e.png)

将数据放在一个4*4得矩阵里，在这个矩阵得末尾进行填充，因为数据不总是16字节来正好填满。这个矩阵我们在下文中称之为‘状态矩阵’

![](https://i.loli.net/2018/11/10/5be6d4b071ccb.png)

初始的一轮将刚才我们创建的矩阵和第一轮的密码4*4矩阵进行异或操作 

![](https://i.loli.net/2018/11/10/5be6d49a48c19.png)

为什么用异或操作？原因很简单，异或快而且开销少–很快的位运算。异或运算使用简单的硬件而且可以并行计算因为没有多余的为需要参与运算。

## 密钥扩散 Part1

![](https://i.loli.net/2018/11/10/5be6d4a35db21.png)

AES需要很多密钥以供后面轮加密的使用。AES通过一个简单的混合操作来将初始的密钥生成这些密钥。这个生成过程很快。尽管它也有一些缺点：（太简单），AES已经足够好了。 

## 密钥扩散 Part2a

![](https://i.loli.net/2018/11/10/5be6d4a4b9bc0.png)

* 首先，将上一轮的密钥的最后一列拿出来然后将这一列的第一个字节放到最后一个位置上，其他位置的字节依次向上移动一个位置 
* 然后，将变换位置后的这一列通过一个替代盒的映射转换为另一列

## 密钥扩散 Part2b

![](https://i.loli.net/2018/11/10/5be6d77e716ec.png)

* 然后把刚才的得到的那一列再与轮常量列相异或，这个常量对每一轮都不一样 
* 最后再把刚才异或之后得到的列与上一轮的密钥的第一列相异或得到第一列

## 密钥扩散 Part3

![](https://i.loli.net/2018/11/10/5be6d7a16de1f.png)

刚才我们得到了第一列，那么第二列怎么得到呢？很简单，用我们上一轮的密钥的第二列和我们刚才得到的第一列异或就得到了新一轮的第二列，第三列第四列用同样的方法依次计算得到（注意256位的密钥更加复杂，我们用的是128位的密钥，也就是16字节）

![](https://i.loli.net/2018/11/10/5be6d7a3edb81.png)

接下来是中间轮了，中间轮是对一系列操作重复执行若干次。重复的次数取决于密钥的长度（128位则重复9次，192位重复11次，256位重复13次）

## 混淆：替代字节

![](https://i.loli.net/2018/11/10/5be6d7aa140df.png)

将每一字节通过S盒换成另外一个字节，我们用图片左下角和右下角的符号表示混淆这一操作

## 扩散 Part1：行移位

![](https://i.loli.net/2018/11/10/5be6d873c70e8.png)

将4*4的矩阵按图左的方式进行行移位，然后按图右的方式进行重新组合得到一个新的4*4矩阵左下角和右下角的符号代表行移位这一操作

## 扩散 Part2：列混淆

![](https://i.loli.net/2018/11/10/5be6d7b3470d0.png)

用列混淆变换将每一列转换成新的一列，算法为模不可约多项式 
图片中左下角和右下角的符号代表列混淆操作

## 加轮密钥

![](https://i.loli.net/2018/11/10/5be6d7b320c69.png)

在每轮的最后，将上一步列混淆得到的矩阵与下一轮的密钥进行异或得到新的矩阵 

![](https://i.loli.net/2018/11/10/5be6d7b888d0d.png)

在最后一轮我们丢弃了列混淆这一操作，因为最后一轮它不会提高安全性了，只会将速度拉低 

![](https://i.loli.net/2018/11/10/5be6d7baa9a7d.png)

每一轮我都对这些比特进行混淆和扩散。而且还把每一轮的密钥都嵌入进去。轮数越多安全性越好！ 

![](https://i.loli.net/2018/11/10/5be6d7bdc58dd.png)

决定到底要多少轮总是面临一个挑战，那就是在安全性和效率之前做出权衡。 

![](https://i.loli.net/2018/11/10/5be6d90717717.png)

有人说可以经过6轮加密就可以了，但是这很不好！如果你仔细观察，你会发现每一轮输出的每一个比特取决于前两轮。为了增加扩散的雪崩效应，我增加了4轮。这是我的安全边界。密钥长度位128位时需要10轮，192位时需要12轮，256位时需要14轮。 

![](https://i.loli.net/2018/11/10/5be6d91cd0c92.png)

每次AES都要先执行异或初始操作，然后执行9轮拥有4项操作的中间轮，最后执行包括三项操作的最后一轮 

![](https://i.loli.net/2018/11/10/5be6d92764280.png)

解密意味着加密的逆过程 

![](https://i.loli.net/2018/11/10/5be6d92c7d328.png)

[相比与ECB而言，CBC更好](http://www.cnblogs.com/happyhippy/archive/2006/12/23/601353.html) 

![](https://i.loli.net/2018/11/10/5be6d92f706d5.png)

但是除了刚才所做的那些类比，究竟发生了些什么呢？ 

![](https://i.loli.net/2018/11/10/5be6d9359c1c5.png)

如果像真正明白这些东西，我们还需要数学基础知识

## 数学！

![](https://i.loli.net/2018/11/10/5be6d938d4b7b.png)

我们思考一个问题，X+X=?你可能会说2X 

![](https://i.loli.net/2018/11/10/5be6d94082669.png)

我们回顾一下数学基础

    (x+1)2=(x+1)(x+1)=x2+x+x+1=x2+2x+1

![](https://i.loli.net/2018/11/10/5be6d94308353.png)

![](https://i.loli.net/2018/11/10/5be6da4d79476.png)

![](https://i.loli.net/2018/11/10/5be6d946d26e0.png)

上图展示了乘法怎么让式子增加的飞快 

![](https://i.loli.net/2018/11/10/5be6d94a63e4e.png)

尽管新的加法让事情变得更加简单，但是x13还是显得太大了，我们怎么才能让这个多项式的最高次不高于7呢？ 

![](https://i.loli.net/2018/11/10/5be6d94ea30ab.png)

我们请来了我们的朋友——时钟数学，怎么做呢？只需要把式子加在一起然后做长除法就可以了。我们要时刻注意余数（这也叫模加法） 

![](https://i.loli.net/2018/11/10/5be6d9527309c.png)

![](https://i.loli.net/2018/11/10/5be6da8d36994.png)

![](https://i.loli.net/2018/11/10/5be6d955aedb2.png)

![](https://i.loli.net/2018/11/10/5be6da9e0dcc9.png)

![](https://i.loli.net/2018/11/10/5be6daaca7689.png)

下面我们到了最艰难的部分了：对数运算。对数运算搞定之后，其他都是小case!对数可以帮助我们将乘法转换为加法（如图） 

![](https://i.loli.net/2018/11/10/5be6dab202879.png)

我们将对数引入我们的新世界，在这里，底数不再是10了，而是简单的多项式x⨁1(如果你不停地乘以x⨁1然后除以m(x)得到余数，你会发现你可以生成所有低于x8的多项式) 

![](https://i.loli.net/2018/11/10/5be6dab7995e7.png)

为什么我们要用这种数学呢？密码学与比特和字节打交道不是吗？OK，还有一个最后的联系，一个7阶的多项式可以表示1字节，因为我们用刚才引入的数学方法生成的多项式的系数只能是1或0 

![](https://i.loli.net/2018/11/10/5be6dabb4b62e.png)

对于字节，我们将多项式加法变成简单的异或。我们可以用对数技巧创建一个表来加快运算

![](https://i.loli.net/2018/11/10/5be6dabd2d9b4.png)

因为我们知道怎么定义的乘法，我们可以为每一个多项式字节找到真正字节的逆运算。因为总共只有255个这样的字节，所以我们可以暴力破解 

![](https://i.loli.net/2018/11/10/5be6dac13169b.png)

现在我们可以理解神秘的S盒了。它将一个字节a应用两个函数。第一个函数是g，找到a的逆元，第二个函数是f，f是故意让这个数学更麻烦来抵挡黑客的进攻 

![](https://i.loli.net/2018/11/10/5be6dac49f310.png)

我们还可以理解那些疯狂的轮常量。我通过不停地乘以x来得到他们 

![](https://i.loli.net/2018/11/10/5be6dac7c37ab.png)

列混淆变换是最困难的。我把每一列看作是一个多项式.用我们新的乘法将它乘以一个特殊的多项式，然后除以x4+1得到余数，然后将其简化成矩阵相乘 

![](https://i.loli.net/2018/11/10/5be6dace4086e.png)

所有的东西都浓缩到上图了